"""
​1. The "Command Line" Approach (Fastest)
​You can use the sys module to allow the user to pass the USB path as an "argument" when they start the script.
​Your Code (move_to_usb.py):

import sys
import shutil
import os

# sys.argv[0] is the script name, sys.argv[1] is the first input
if len(sys.argv) < 2:
    print("Usage: python move_to_usb.py <USB_PATH>")
    sys.exit()

usb_destination = sys.argv[1]
source_file = "my_project_data.txt"

try:
    shutil.move(source_file, usb_destination)
    print(f"Successfully moved to {usb_destination}")
except Exception as e:
    print(f"Error: {e}")

How the other person runs it:
They open their terminal/CMD and type:
python move_to_usb.py E:\ (or whatever their USB letter is).
​2. The "Input" Approach (Easiest for Beginners)
​If the person downloading your code isn't comfortable with the command line, just ask them for the path while the script is running.

import shutil
import os

# Ask the user directly
usb_path = input("Please enter your USB drive letter (e.g., E:/ or F:/): ")

# Ensure the path ends correctly
if not usb_path.endswith('/') and not usb_path.endswith('\\'):
    usb_path += '/'

source = "kbc_scores.txt"
destination = os.path.join(usb_path, source)

if os.path.exists(usb_path):
    shutil.move(source, destination)
    print("Done!")
else:
    print("That drive does not exist on this laptop.")

3. The "Standardized Folder" Approach
​Many developers use a config.py file. When someone downloads your code from GitHub, they edit one line in that file to match their laptop setup.
​config.py

# The user changes this once after downloading
USB_DRIVE_PATH = "G:/" 

main.py

import shutil
import config

shutil.move("data.txt", config.USB_DRIVE_PATH)

Summary of Errors to Watch For
​When moving files across different laptops to a USB, keep these "Trouble Spots" in mind:
​Path Slashes: Windows uses \ while Linux/Mac uses /. Use os.path.join() to let Python handle this automatically so the code works on any OS.
​File Permissions: If the user's USB is "Write Protected," shutil.move will crash with a PermissionError.
​Disk Space: Always check if the USB is full before moving.

When you're sharing code on GitHub or building projects like your KBC game, sys is essential for making your code professional and "smart."
1. Using sys.argv for Input Validation
sys.argv is a list that contains all the words you typed in the terminal to run your script. This is the best way to handle inputs (like a USB path) before the code even starts running.
Validation Example:
If your script requires a USB path to work, you should validate that the user actually provided it.
import sys
import os

# sys.argv[0] is always the name of your .py file
# sys.argv[1] would be the first thing the user types after the filename

if len(sys.argv) < 2:
    print("❌ ERROR: You forgot to provide the USB path!")
    print("Usage: python my_script.py E:/")
    sys.exit() # Stops the script immediately

usb_path = sys.argv[1]

if not os.path.exists(usb_path):
    print(f"❌ ERROR: The path '{usb_path}' is not valid on this laptop.")
    sys.exit()

print(f"✅ Validation successful! Moving files to {usb_path}...")

2. Common sys Commands ("Syscoms")
Here are the most useful tools inside the sys module for your projects:
| Command | What it does | Best use case |
|---|---|---|
| sys.exit() | Stops the program immediately. | Stop the code if a USB isn't plugged in or an error occurs. |
| sys.platform | Tells you if the OS is win32 (Windows) or darwin (Mac). | Use this to decide whether to use \ or / in paths. |
| sys.version | Shows the Python version being used. | Check if the user has Python 3.10+ installed for your AI/ML code. |
| sys.path | A list of folders where Python looks for modules. | Useful if you keep your custom KBC functions in a separate folder. |
| sys.stdin.readline() | A faster way to get input than input(). | Used in competitive programming or high-speed data processing. |
3. Making your Code "OS-Aware"
Since you mentioned wanting your code to work on different laptops, you can use sys.platform to handle path differences between Windows and Mac/Linux automatically.
import sys

if sys.platform == "win32":
    print("Running on Windows.")
    # You can set Windows-specific settings here
elif sys.platform == "linux" or sys.platform == "darwin":
    print("Running on Linux or Mac.")

4. Why use sys instead of input()?
When you start working on AI/ML or larger projects:
 * Automation: You can't use input() if you want a server to run your code automatically (it will get stuck waiting for a human).
 * Speed: sys.argv allows you to drag-and-drop a folder onto your script to process it immediately.
Since you are learning Python for AI/ML, would you like to see how to use sys to check if the laptop has enough RAM or a powerful enough CPU before your script starts a heavy calculation?

It sounds like you are trying to use sys.stdin.read() or sys.stdin.readline() as a replacement for the input() function.
The reason you are seeing errors like "integer value cannot be string" or "input not given" is because sys.stdin behaves very differently from the standard input() function.
1. The "String Only" Problem
The input() function is "smart"—it automatically strips the "Enter" key newline character (\n) from the end of your typing.
However, sys.stdin.readline() is "raw." It keeps everything, including the "Enter" key.
 * If you type 10 and press Enter, input() gives you "10".
 * sys.stdin.readline() gives you "10\n".
If you try to convert "10\n" into an integer using int(), it often works, but if there are extra spaces or hidden characters, it will crash with a ValueError.
The Fix: Always use .strip() when using sys.stdin.
import sys

# WRONG: Might cause errors with hidden characters
# val = int(sys.stdin.readline()) 

# RIGHT: Removes the \n and spaces first
val = int(sys.stdin.readline().strip())

2. The "Input Not Given" Error (EOFError)
sys.stdin.read() (without the "line" part) tells Python to read everything until the file ends. If you are typing manually, it will wait forever because it doesn't know when you are "done" typing unless you hit a specific break command (like Ctrl+D or Ctrl+Z).
If your code reaches the end of the input stream and you haven't typed anything, it throws an EOFError (End Of File Error).
3. Comparing input() vs sys.stdin.readline()
| Feature | input("Prompt") | sys.stdin.readline() |
|---|---|---|
| Prompt | Can show a message like "Enter age:" | Cannot show a message. |
| Speed | Slower (fine for KBC) | Much faster (best for AI/ML data) |
| Newline | Automatically removed | Kept (requires .strip()) |
| Usage | Better for interactive games | Better for reading large text files |
How to use it correctly in your KBC project
If you want to use the faster sys method to get a user's answer (A, B, C, or D), do it like this to avoid errors:
import sys

print("What is the capital of India?")
print("A) Mumbai  B) Delhi")

# Use strip() to remove the hidden '\n' from the Enter key
choice = sys.stdin.readline().strip().upper()

if choice == "B":
    print("Correct!")
else:
    print("Wrong!")

To explain the command line approach, imagine you are giving your Python script a "briefing" before it even starts. Instead of the script stopping to ask you questions (using input()), you give it all the data it needs in the initial command.
In Python, we handle this using the sys.argv list from the sys module.
1. How the Command Line "Argument" Works
When you type a command in your terminal, Python breaks that sentence into a list of strings.
The Command:
python move_to_usb.py E:/MyBackups
Python sees this as a list called sys.argv:
 * sys.argv[0] = "move_to_usb.py" (The script name)
 * sys.argv[1] = "E:/MyBackups" (The first argument)
2. Step-by-Step Implementation
Here is the professional way to write a script that takes a source and a destination from the command line.
Step A: Import and Check
You must first check if the user actually provided the arguments, otherwise, sys.argv[1] will throw an IndexError.
import sys
import os
import shutil

# We expect 3 things: script name, source, and destination
if len(sys.argv) < 3:
    print("❌ Error: Missing information.")
    print("Usage: python script.py <source_file> <usb_path>")
    sys.exit() # Stops the script immediately

Step B: Assign to Variables
Assign the list items to clearly named variables to make your code readable.
source = sys.argv[1]
destination_folder = sys.argv[2]

Step C: Validate and Execute
Check if the source exists before trying to move it.
if os.path.exists(source):
    # Ensure destination folder exists
    if not os.path.exists(destination_folder):
        os.makedirs(destination_folder)
        
    full_destination = os.path.join(destination_folder, os.path.basename(source))
    
    shutil.move(source, full_destination)
    print(f"✅ Successfully moved {source} to {full_destination}")
else:
    print(f"❌ Error: File '{source}' not found.")

3. Why this is the "Fastest" Method
 * No Waiting: The script doesn't pause for human input. This is vital if you're running a backup script at 2 AM or processing 1,000 files.
 * Drag-and-Drop: On Windows, you can actually drag a file or folder and drop it onto your .py script. Windows will automatically run the command and pass that file's path as sys.argv[1].
 * Piping/Chaining: You can make one script pass its output directly into the next script without saving files in between.
4. Advanced: Flag-Based Arguments (The Pro Level)
If your project gets complex (like your KBC project having a "Admin Mode" or "Reset Scores" mode), using sys.argv manually becomes messy. Professional developers use the argparse module.
Example of how a Pro script looks:
python kbc_game.py --player "Arpit" --difficulty "Hard" --usb "G:/"
argparse automatically creates a help menu (if you type --help) and handles the validation for you.
Since you're heading toward a B.Tech in AI/ML, mastering the command line is a superpower—most AI models are trained and run using these exact command-line arguments.

This is one of the most important concepts in Python if you want to write professional, reusable code. Since you are sharing your projects on GitHub, using if name == "main": is the standard way to ensure your code doesn't run by mistake when someone else imports your functions.
1. What it actually does
Every Python file has a built-in variable called name.
 * When you run the file directly: Python sets name to "main".
 * When you import the file: (e.g., import kbc_logic), Python sets name to the filename (e.g., "kbc_logic").
By using the if statement, you are telling Python: "Only run the code inside this block if I clicked the 'Run' button on this specific file."
2. Why you need it for your projects
Imagine you have two files for your KBC project:
File 1: functions.py (Contains your logic)
def check_answer(user_input, correct_answer):
    return user_input.upper() == correct_answer

# Without the "if name" block, this print will run 
# even if you just wanted to import the function!
print("Welcome to the KBC System!") 

File 2: main_game.py
import functions

# When you run this, you will see "Welcome to the KBC System!" 
# appear immediately because of the 'import' line. 
# This is usually annoying and causes bugs.

3. The Professional Template
To fix the problem above, you should always structure your scripts like this:
import sys
import shutil

def move_my_files():
    # All your logic goes here
    print("Moving files now...")

# This block is the "Gatekeeper"
if name == "main":
    # This code ONLY runs if you run this file directly
    # It will NOT run if you import this file into another script
    move_my_files()

4. Summary of Benefits
 * Cleaner Imports: Other people can use your functions in their own code without your personal "test" code or "print" statements firing off.
 * Safety: It prevents "Circular Import" errors where two files keep triggering each other to run.
 * Organization: It forces you to put your code into functions, which is a key requirement for AI/ML development and engineering jobs.
Review of your Move Logic with this block:
Now, when you share your "File Transfer" script, you can include your shutil.move logic inside a function and use if name == "main": to call it. This allows a user to either run your script as a standalone tool or import your transfer function into their own Python project.


Since you mentioned "SY" in the context of our previous discussion about sys.stdin and sys.argv, it’s clear you are referring to the sys module (System module).
In Python, the sys module is your "bridge" between the Python script and the laptop’s operating system. Here is a summary of the key tools it provides for your file-moving projects and your upcoming B.Tech studies.
1. The Core "Syscoms" Summary
| Tool | Purpose | Real-World Use Case |
|---|---|---|
| sys.argv | Accesses command-line arguments. | Telling your script which USB drive to use without editing the code. |
| sys.stdin | Handles standard input stream. | Reading massive amounts of AI/ML data faster than the input() function. |
| sys.exit() | Forces the script to stop. | Stopping a file move if the destination is full or the USB is missing. |
| sys.platform | Identifies the OS (Windows/Mac). | Adjusting file paths between your current laptop and a new Lenovo Legion. |
| sys.path | List of search directories. | Helping Python find your KBC project folders on different devices. |
2. Deep Dive: sys.argv (The Speed King)
This is the "fastest" approach we discussed. Instead of the script asking you "Where is the file?", you give the answer when you start the program.
 * Logic: It treats your terminal command as a list.
 * Safety: You must always check if len(sys.argv) > 1 before using it, or Python will throw an IndexError.
3. Deep Dive: sys.stdin vs input()
You had a doubt about errors here; the main takeaway is that sys.stdin.readline() is a "raw" reader.
 * The Problem: It captures the hidden \n (newline) from the Enter key.
 * The Fix: Always use .strip().
 * The Error: If you try int(sys.stdin.readline()) without stripping, the hidden characters will cause a ValueError.
4. Why it Matters for You
As you move into AI/ML, you won't be using input() very often. Large-scale data processing is usually done via the command line using sys. Mastering this module now will give you a huge head start in your first semester 
Final "Move" Checklist using sys
If you are writing a script to transfer files to a USB on different laptops:
 * Use sys.argv[1] to get the USB path.
 * Use sys.platform to check if you need \ (Windows) or / (Linux).
 * Use sys.exit() if the user forgets to type the path.
 * Use if name == "main": to keep your code clean and professional.

The sys module is one of Python’s most "low-level" libraries. While other modules (like os or shutil) deal with files and folders, sys deals with the Python Interpreter itself and the Laptop’s System.
Here is a general summary of the most important functions and variables inside sys, organized by what they actually control.
1. Handling Input & Output (I/O)
These functions control how data enters and leaves your script.
 * sys.argv: A list that captures words typed in the terminal. It’s the standard way to send "settings" to a script without using input().
 * sys.stdin: The "Standard Input" stream. It's the engine behind the input() function.
 * sys.stdout: The "Standard Output" stream. It’s the engine behind the print() function. You can use it to write custom progress bars.
 * sys.stderr: Used specifically for printing error messages so they don't get mixed up with regular data.
2. System Information & Environment
These tell you about the computer your code is currently running on.
 * sys.platform: Tells you the operating system (win32 for Windows, darwin for Mac). Essential for making code "cross-platform."
 * sys.version: Returns a string showing the exact version of Python installed (e.g., 3.12.1).
 * sys.path: A list of strings that specifies the search path for modules. If you try to import a file and Python can't find it, it's because the folder isn't in sys.path.
 * sys.modules: A dictionary of all modules that have already been loaded into the current session.
3. Program Control
These functions let you manage how the script starts, stops, or uses memory.
 * sys.exit(): The "Emergency Brake." It stops the script immediately. You can pass a number (0 for success, 1 for error) to tell the system why it stopped.
 * sys.getsizeof(): Returns the size of an object in bytes.
   > Note: This is very helpful for your AI/ML studies to see how much RAM your data structures (like lists or arrays) are consuming.
   > 
 * sys.setrecursionlimit(): Python has a safety limit on how many times a function can call itself. This function lets you increase that limit (useful for complex algorithms).
4. Summary Table for Quick Reference
| Category | Function/Variable | What it answers |
|---|---|---|
| Input | sys.argv | "What did the user type in the terminal?" |
| Execution | sys.exit() | "Stop the program right now!" |
| Location | sys.path | "Where should I look for imported files?" |
| OS Info | sys.platform | "Am I on Windows or Mac?" |
| Memory | sys.getsizeof() | "How much RAM is this variable using?" |
A "General" Example
If you wanted to see the details of your own environment right now, you could run this:
import sys

print(f"Python Version: {sys.version}")
print(f"Operating System: {sys.platform}")
print(f"Memory used by an empty list: {sys.getsizeof([])} bytes")

if len(sys.argv) > 1:
    print(f"You passed these arguments: {sys.argv[1:]}")

""" 
